<h1 align = "center"> 
    Introduzione alla Binary Exploitation
    <img src='img/binary_exploit.jpg' width=400px height=200px />
</h1>

Introduzione alla binary exploitation(ita) prendendo spunto dalla rivista phrack volume 49, articolo 14 (http://www.phrack.org/issues/49/14.html#article )

## Distruggere lo stack per divertimento e profitto

In molti binari scritti e compilati in C è possibile <strong>corrompere lo stack</strong> (zona di memoria utilizzata dal programma) scrivendo oltre il limite di un particolare array definito in qualche modo. Se abbaiamo un codice scritto male che permette ad un utente malevolo di scrivere oltre al limite di un array questo puo andare a corrompere la memoria in un modo specifido andando a cambiare quello che viene chiamato <strong>return address</strong> (l'indirizzo di ritorno). Andando a cambiare l'indirizzo di ritorno un attaccante è in grado di redirigere il flusso del programma a proprio piacimento; in poche parole è grado di prendere il controllo del binario e <strong>far eseguire ciò che vuole lui</strong>.

Questo tipo di errore è chiamato <strong>buffer overflow</strong>, cioe una condizione di errore che si verifica a runtime quando in un buffer di una data dimensione vengono scritti dati di dimensioni maggiori

### Cosa si intende per Binary Exploitation?

<img src='img/rop-chain.png' width=400px height=200px/>

La <strong>Binary Exploitation</strong> è quel ramo della sicurezza informatica che attraverso vari metodi ti consente di <strong>controllare un binario modificando la sua esecuzione</strong>, quindi cambiando la logica iniziale per cui il programma è stato scritto <strong>per ottenere i nostri scopi</strong> (molti eseguibili vengono eseguiti come utenti root, cosa succede se  modifichiamo l'esecuzione del programma e al posto di tutto il suo codice facciamo eseguire un codice che indica di aprire una shell root? Succede che abbiamo il pieno controllo sul sistema in quanto root !!!)

## 1. Introduzione

Nel 1996 ci sono stati un numero molto elefato di vulnerabilità legate ai buffer overflow che son stati sia scoperti che exploitati (sfruttati per scopi malevoli) Per esempio i software syslog, splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at, ecc ecc. <strong>Questo documento tenta di spiegare quali buffer overflow sono e come funzionano i loro exploit.</strong>

È richiesta una conoscenza base di Assembly. La comprensione dei concetti di memoria virtuale e l'esperienza con gdb(debugger) sono molto utili ma non necessarie. Supponiamo inoltre di lavorare con una CPU Intel x86 e che il sistema operativo sia Linux.

<strong>Definizioni base prima di iniziare:</strong> un <strong>buffer</strong> è semplicemente un blocco contiguo di memoria del computer che contiene più istanze dello stesso tipo di dato. I programmatori C normalmente associano la parola buffer agli array. Più comunemente, agli array di caratteri. Gli array, come tutte le variabili in C, possono essere dichiarati statici o dinamici. Le <strong>variabili statiche</strong> sono allocate al momento del caricamento nel segmento dati. Le <strong>variabili dinamiche/automatiche</strong> sono allocate a runtime nello stack. Overflow significa traboccare, straripare o riempire oltre il limite, i bordi o i confini. In questo documento Ci occcuperemo solo dei stack-based buffer overflow (cioe sui buffer overflow basati solo sullo stack e non altre memorie tipo heap ecc).



## 2. Organizzazione della memoria di un processo

Per capire che cos'è un buffer allocato nello stack (e quindi per capire come potremmo attacare), dobbiamo prima capire come un processo è suddiviso in termini di memoria, cioe com'è suddivisa la memoria di un processo? I Processi sono suddivisi in <strong>5 zone di memorie distinte</strong>:

1.  <strong>text segment</strong>: noto anche come segement code o semplicemente come text, è la regione del binario che contiene il codice da eseguire. i dati all'interno di questo spazio di memoria possono essere solo letti e  qualsiasi tentativo di scriverci comporterà una violazione di segmentazione; quindi un <i>segmentation fault</i>, quindi una violazione della memoria. 
   
   Esempio di segmentation fault:
   
   ```c
   #include <stddef.h> //include NULL
   
   struct Node{
       int data;
   };
   
   int main(void){
       struct Node* p = NULL;
       p->data = 69; //accediamo a data prima di allocare memoria
                     //dinamica al puntatore
   }
   
   /* 
       se al posto di mettere NULL mettevamo un indirizzo che poi andava
       a puntare alla regione del text avremmo avuto comunque un segfault
   */
   ```
