<h1 align = "center"> 
    Introduzione alla Binary Exploitation
    <img src='img/binary_exploit.jpg' width=400px height=200px />
</h1>

Introduzione alla binary exploitation(ita) prendendo spunto dalla rivista phrack volume 49, articolo 14 (http://www.phrack.org/issues/49/14.html#article )

## Distruggere lo stack per divertimento e profitto

In molti binari scritti e compilati in C è possibile <strong>corrompere lo stack</strong> (zona di memoria utilizzata dal programma) scrivendo oltre il limite di un particolare array definito in qualche modo. Se abbaiamo un codice scritto male che permette ad un utente malevolo di scrivere oltre al limite di un array questo puo andare a corrompere la memoria in un modo specifido andando a cambiare quello che viene chiamato <strong>return address</strong> (l'indirizzo di ritorno). Andando a cambiare l'indirizzo di ritorno un attaccante è in grado di redirigere il flusso del programma a proprio piacimento; in poche parole è grado di prendere il controllo del binario e <strong>far eseguire ciò che vuole lui</strong>.

Questo tipo di errore è chiamato <strong>buffer overflow</strong>, cioe una condizione di errore che si verifica a runtime quando in un buffer di una data dimensione vengono scritti dati di dimensioni maggiori

### Cosa si intende per Binary Exploitation?

<img src='img/rop-chain.png' width=400px height=200px/>

La <strong>Binary Exploitation</strong> è quel ramo della sicurezza informatica che attraverso vari metodi ti consente di <strong>controllare un binario modificando la sua esecuzione</strong>, quindi cambiando la logica iniziale per cui il programma è stato scritto <strong>per ottenere i nostri scopi</strong> (molti eseguibili vengono eseguiti come utenti root, cosa succede se  modifichiamo l'esecuzione del programma e al posto di tutto il suo codice facciamo eseguire un codice che indica di aprire una shell root? Succede che abbiamo il pieno controllo sul sistema in quanto root !!!)

## 1. Introduzione

Nel 1996 ci sono stati un numero molto elevato di vulnerabilità legate ai buffer overflow che son stati sia scoperti che exploitati (sfruttati per scopi malevoli) Per esempio i software syslog, splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at, ecc ecc. <strong>Questo documento tenta di spiegare quali buffer overflow sono e come funzionano i loro exploit.</strong>

È richiesta una conoscenza base di Assembly. La comprensione dei concetti di memoria virtuale e l'esperienza con gdb(debugger) sono molto utili ma non necessarie. Supponiamo inoltre di lavorare con una CPU Intel x86 e che il sistema operativo sia Linux.

<strong>Definizioni base prima di iniziare:</strong> un <strong>buffer</strong> è semplicemente un blocco contiguo di memoria del computer che contiene più istanze dello stesso tipo di dato. I programmatori C normalmente associano la parola buffer agli array. Più comunemente, agli array di caratteri. Gli array, come tutte le variabili in C, possono essere dichiarati statici o dinamici. Le <strong>variabili statiche</strong> sono allocate al momento del caricamento nel segmento dati. Le <strong>variabili dinamiche/automatiche</strong> sono allocate a runtime nello stack. Overflow significa traboccare, straripare o riempire oltre il limite, i bordi o i confini. In questo documento Ci occcuperemo solo dei stack-based buffer overflow (cioe sui buffer overflow basati solo sullo stack e non altre memorie tipo heap ecc).

## 2. Organizzazione della memoria di un processo

Per capire che cos'è un buffer allocato nello stack (e quindi per capire come potremmo attacare), dobbiamo prima capire come un processo è suddiviso in termini di memoria, cioe com'è suddivisa la memoria di un processo? I Processi sono suddivisi in <strong>5 zone di memorie distinte</strong>:

1. <strong>text segment</strong>: noto anche come code segment o semplicemente come text, è la regione del binario contenente il codice da eseguire. i dati all'interno di questo spazio di memoria possono essere solo letti e  qualsiasi tentativo di scriverci comporterà un <i>segmentation fault</i>, quindi una violazione della memoria. (es in figura 2.1)

2. <strong>data segment</strong> noto anche come data region o semplicemente data, oppure global, è la regione del binario che contiene tutte le variabili globali e statiche inizializzate

3. <strong>bss segment</strong> è la regione del binario in cui sono contenute tutte le variabili globali e statiche non inizializzate

4. <strong>heap segment</strong> è una memoria dinamica che ogni binario ha in modo che il programma possa accederci quando piu a bisogno(cresce durante il runtime cioè durante l'esecuzione del programma), i programmi in C accedono alla heap tramite le funzioni malloc, calloc, realloc e free

5. <strong>stack segment</strong> è una memoria statica che contiene le variabili locali dichiarate all'interno delle funzioni C (compreso main) gestisce le chiamate di funzione, gli indirizzi di ritorno e i parametri delle funzioni

<i><strong>(2.1)</strong> Esempio di segmentation fault:</i>

```c
#include <stddef.h> //include NULL

struct Node{
    int data;
};

int main(void){
    struct Node* p = NULL;
    p->data = 69; //accediamo a data prima di allocare memoria
                  //dinamica al puntatore
}
```

se al posto di mettere NULL mettessimo un indirizzo che poi andrebbe a puntare alla regione del text avremmo avuto comunque un <strong>segfault</strong>

## 3. Cos'è di preciso lo stack?

Lo <strong>stack </strong> è una tipo di struttura dati astratta(astratta perchè non conosciamo la tipologia di dati). Essa è caratterizzata dalla logica chiamata <strong>LIFO</strong> (**L**ast <strong>i</strong>n **F**irst <strong>O</strong>ut, il primo ad entrare è sempre l'ultimo ad uscire).

E come se avessi una manciata di libri e li mettessi uno sopra l'altro, a rigor di logica il primo libro che avrò messo sara l'ultimo che prendo (cominciando appunto a togliere i libri dall'alto)

È possibile fare molte operazioni con lo stack(push, pop, peek/top, isEmpty, isFull, getSize, clear, search) ma le più importanti sono 2:

- <strong>push</strong>  ➞ l'operazione di push aggiunge un elemento in cima (aumentando la dimensione dello stack) [ esempio in figura 3.1] 

- <strong>pop</strong> ➞ l'operazione di pop estrae un elemento partendo dalla cima(diminunendo la dimensione dello stack) [esempio in figura 3.2] 

<i>**(figura 3.1)** - esempio di push</i> {++}

```
           PUSH b3   ____ 
 ____               |____| book 3   
|____| book 2  =>   |____| book 2
|____| book 1       |____| book 1
```

<i><strong>(figura 3.2)</strong> - esempio di pop</i> {--}

```
 ____         POP               POP
|____| book 3      ____
|____| book 2  => |____| book 2 =>  ____
|____| book 1     |____| book 1    |____| book1
```
